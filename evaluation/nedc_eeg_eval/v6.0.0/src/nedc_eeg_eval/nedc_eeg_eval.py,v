head	1.23;
access;
symbols;
locks; strict;
comment	@# @;


1.23
date	2025.08.23.05.19.11;	author tup91526;	state Exp;
branches;
next	1.22;

1.22
date	2025.07.04.11.40.21;	author picone;	state Exp;
branches;
next	1.21;

1.21
date	2025.07.01.16.00.23;	author picone;	state Exp;
branches;
next	1.20;

1.20
date	2025.07.01.15.58.02;	author tup91526;	state Exp;
branches;
next	1.19;

1.19
date	2025.02.26.04.27.14;	author picone;	state Exp;
branches;
next	1.18;

1.18
date	2025.02.18.02.14.05;	author tup91526;	state Exp;
branches;
next	1.17;

1.17
date	2025.02.06.01.39.42;	author tup91526;	state Exp;
branches;
next	1.16;

1.16
date	2024.10.04.00.30.35;	author picone;	state Exp;
branches;
next	1.15;

1.15
date	2024.10.04.00.19.07;	author picone;	state Exp;
branches;
next	1.14;

1.14
date	2024.09.22.22.58.20;	author picone;	state Exp;
branches;
next	1.13;

1.13
date	2024.09.22.22.10.13;	author picone;	state Exp;
branches;
next	1.12;

1.12
date	2024.08.10.16.34.10;	author picone;	state Exp;
branches;
next	1.11;

1.11
date	2024.07.26.00.45.49;	author picone;	state Exp;
branches;
next	1.10;

1.10
date	2024.07.26.00.44.16;	author tup86891;	state Exp;
branches;
next	1.9;

1.9
date	2023.07.04.20.24.30;	author picone;	state Exp;
branches;
next	1.8;

1.8
date	2023.07.04.12.31.50;	author picone;	state Exp;
branches;
next	1.7;

1.7
date	2022.05.15.00.25.43;	author picone;	state Exp;
branches;
next	1.6;

1.6
date	2022.04.23.16.37.52;	author picone;	state Exp;
branches;
next	1.5;

1.5
date	2022.04.19.01.01.44;	author picone;	state Exp;
branches;
next	1.4;

1.4
date	2022.04.19.00.50.30;	author picone;	state Exp;
branches;
next	1.3;

1.3
date	2021.02.27.00.44.20;	author tuj64267;	state Exp;
branches;
next	1.2;

1.2
date	2021.02.02.22.16.51;	author picone;	state Exp;
branches;
next	1.1;

1.1
date	2021.02.02.21.58.35;	author picone;	state Exp;
branches;
next	;


desc
@initial version.
@


1.23
log
@updated to final version for v2.0.2
@
text
@#!/usr/bin/env python
#
# file: $(NEDC_NFC)/util/python/nedc_eeg_eval/nedc_eeg_eval.py
#
# revision history:
#
# 20241003 (JP): added a timestamp log message
# 20240515 (BL): refactored code to match new naming, removed comp version
# 20220513 (JP): refactored the code to use the new ann tools library
# 20220418 (JP): updated I/O to support csv and xml using the new ann tools
# 20210202 (JP): obsoleted the NIST scoring software
# 20200730 (LV): merged research and competition versions, added NIST option
# 20170730 (JP): moved parameter file constants out of this driver
# 20170728 (JP): added error checking for duration
# 20170716 (JP): upgraded to using the new annotation tools.
# 20170527 (JP): added epoch-based scoring
# 20150520 (SZ): modularized the code
# 20170510 (VS): encapsulated the three scoring metrics 
# 20161230 (SL): revision for standards
# 20150619 (SZ): initial version
#------------------------------------------------------------------------------

# import system modules
#
import os
import sys
import time

# import NEDC support modules
#
import nedc_cmdl_parser as ncp
import nedc_debug_tools as ndt
import nedc_file_tools as nft

# import NEDC scoring modules
#
import nedc_eeg_eval_common as nec
import nedc_eeg_eval_dpalign as ndpalign
import nedc_eeg_eval_epoch as nepoch
import nedc_eeg_eval_ovlp as novlp
import nedc_eeg_eval_taes as ntaes
import nedc_eeg_eval_ira as nira

#------------------------------------------------------------------------------
#
# global variables are listed here
#
#------------------------------------------------------------------------------

# set the filename using basename                                              
#                                                                              
__FILE__ = os.path.basename(__file__)

# define the help file and usage message:
#  since this is released software, we use an src directory
#
HELP_FILE = "$NEDC_NFC/docs/help/nedc_eeg_eval.help"
USAGE_FILE = "$NEDC_NFC/docs/usage/nedc_eeg_eval.usage"

# define the program options:                                                  
#  note that you cannot separate them by spaces                                
#
ARG_ODIR = "--odir"
ARG_ABRV_ODIR = "-o"

ARG_PARM = "--parameters"
ARG_ABRV_PARM = "-p"


# define default values for arguments:
#  note we assume the parameter file is in the same
#  directory as the source code.
#
DEF_PFILE = "$NEDC_NFC/docs/params/nedc_eeg_eval_params_v00.toml"
DEF_ODIR = "./output"

# define the required number of arguments
#
NUM_ARGS = 2

# define the names of the output files
#
NEDC_SUMMARY_FILE = "summary.txt"
NEDC_DPALIGN_FILE = "summary_dpalign.txt"
NEDC_EPOCH_FILE = "summary_epoch.txt"
NEDC_OVLP_FILE = "summary_ovlp.txt"
NEDC_TAES_FILE = "summary_taes.txt"
NEDC_IRA_FILE = "summary_ira.txt"

# define formatting constants
#
NEDC_EVAL_SEP = nft.DELIM_EQUAL * 78
NEDC_VERSION = "v6.0.0"

# define class definitions:
#  this can be overridden by using a parameter file. multi-class
#  scoring can be done by making appropriate changes to the
#  parameter file.
#
SEIZ = "SEIZ"
BCKG = "BCKG"
CLASSES = [SEIZ, BCKG]

#------------------------------------------------------------------------------
#
# functions are listed here
#
#------------------------------------------------------------------------------

# declare a global debug object so we can use it in functions
#
dbgl = ndt.Dbgl()

# function: main
#
def main(argv):

    # create a command line parser                                        
    #                                                                          
    cmdl = ncp.Cmdl(USAGE_FILE, HELP_FILE)

    # define the command line arguments
    #
    cmdl.add_argument("files", type = str, nargs = '*')
    cmdl.add_argument(ARG_ABRV_ODIR, ARG_ODIR, type = str)
    cmdl.add_argument(ARG_ABRV_PARM, ARG_PARM, type = str)
    
    # parse the command line
    #
    args = cmdl.parse_args()
    
    # check if the proper number of lists has been provided
    #
    if len(args.files) != NUM_ARGS:
        cmdl.print_usage()
        sys.exit(os.EX_SOFTWARE)
            
    # set argument values
    #
    odir = nft.get_fullpath(DEF_ODIR)
    if args.odir is not None:
        odir = args.odir

    if args.parameters is not None:
        pfile = args.parameters

    if args.parameters is None:
        pfile = nft.get_fullpath(DEF_PFILE)
    
    # load parameters
    #
    nedc_dpalign = nft.load_parameters(pfile, ndpalign.NEDC_DPALIGN)
    nedc_epoch = nft.load_parameters(pfile, nepoch.NEDC_EPOCH)
    nedc_ovlp = nft.load_parameters(pfile, novlp.NEDC_OVLP)
    nedc_taes = nft.load_parameters(pfile, ntaes.NEDC_TAES)
    nedc_ira = nft.load_parameters(pfile, nira.NEDC_IRA)

    # load the scoring map
    #
    tmpmap = nft.load_parameters(pfile, nec.PARAM_MAP)
    if (tmpmap == None):
        print("Error: %s (line: %s) %s: %s (%s)" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               "error loading the scoring map",  pfile))
        sys.exit(os.EX_SOFTWARE)

    # convert the map
    #
    scmap = nft.generate_map(tmpmap)
    if (scmap == None):
        print("Error: %s (line: %s) %s: error converting the map" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)

    if dbgl > ndt.BRIEF:
        print("%s (line: %s) %s: scoring map = " %
              (__FILE__, ndt.__LINE__, ndt.__NAME__), scmap)

    # set the input lists
    #
    fname_ref = args.files[0]
    fname_hyp = args.files[1]

    # parse the ref and hyp file lists 
    #
    reflist = nft.get_flist(fname_ref)
    hyplist = nft.get_flist(fname_hyp)

    # ensure file lists are valid
    #
    if None in reflist or len(reflist) == 0:
        print("Error: %s (line: %s) %s: invalid ref list" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               ))
        sys.exit(os.EX_SOFTWARE)

    # ensure file lists are valid
    #
    if None in hyplist or len(hyplist) == 0:
        print("Error: %s (line: %s) %s: invalid hyp list" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               ))
        sys.exit(os.EX_SOFTWARE)

    # fetch absolute paths for ref and hyp lists
    #
    reflist = [nft.get_fullpath(ref_file) for ref_file in reflist]
    hyplist = [nft.get_fullpath(hyp_file) for hyp_file in hyplist]

    if len(reflist) != len(hyplist):
        print("Error: %s (line: %s) %s: %s (ref: %s, hyp: %s)" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               "ref and hyp list lengths dont match",
               len(reflist), len(hyplist)))
        sys.exit(os.EX_SOFTWARE)
        
    if dbgl > ndt.NONE:
        print("%s (line: %s) %s: ref list = " %
              (__FILE__, ndt.__LINE__, ndt.__NAME__), reflist)
        print("%s (line: %s) %s: hyp list = " %
              (__FILE__, ndt.__LINE__, ndt.__NAME__), hyplist)

    ref_anns = nec.parse_files(reflist, scmap)
    hyp_anns = nec.parse_files(hyplist, scmap)

    # ensure annotations were parsed correctly
    #
    if ref_anns == False:
        print("Error: %s (line: %s) %s: ref annotations failed to load" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               ))
        sys.exit(os.EX_SOFTWARE)
    if hyp_anns == False:
        print("Error: %s (line: %s) %s: hyp annotations failed to load" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               ))
        sys.exit(os.EX_SOFTWARE)

    
    if dbgl > ndt.NONE:
        print("%s (line: %s) %s: ref_anns = " %
              (__FILE__, ndt.__LINE__, ndt.__NAME__), ref_anns)
        print("%s (line: %s) %s: hyp_anns = " %
              (__FILE__, ndt.__LINE__, ndt.__NAME__), hyp_anns)
                
    # display debug information
    #
    if dbgl > ndt.NONE:
        print("command line arguments:")
        print(" output directory = %s" % (odir))
        print(" competition = %d" % (bool(args.competition)))
        print(" ref file  = %s" % (args.files[0]))
        print(" hyp file = %s" % (args.files[1]))
        print(" ref_anns = ", ref_anns)
        print(" hyp_anns = ", hyp_anns)
        print("")

    # check for mismatched file lists:
    #  note that we do this here so it is done only once, rather than
    #  in each scoring method
    #
    if (ref_anns == None) or (hyp_anns == None):
        print("Error: %s (line: %s) %s: %s (ref: %s) and (hyp: %s)" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               "error loading filelists", fname_ref, fname_hyp))
        sys.exit(os.EX_SOFTWARE)
    elif len(ref_anns) != len(hyp_anns):
        print("Error: %s (line: %s) %s: (ref: %d) and (hyp: %d) %s" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               len(ref_anns), len(hyp_anns), "have different lengths"))
        sys.exit(os.EX_SOFTWARE)

    # create the output directory and the output summary file
    #               
    print(" ... creating the output directory ...")
    if nft.make_dir(odir) == False:
        print("Error: %s (line: %s) %s: error creating output directory (%s)" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__, odir))
        sys.exit(os.EX_SOFTWARE)

    fname = nft.concat_names(odir, NEDC_SUMMARY_FILE)
    fp = nft.make_fp(fname)

    # print the log message
    #
    fp.write("%s" % (dbgl.log(__file__, NEDC_VERSION) + nft.DELIM_NEWLINE))

    # print the header of the summary file showing the relevant information
    #
    fp.write("%s" % (NEDC_EVAL_SEP + nft.DELIM_NEWLINE))
    fp.write("File: %s" % (fname + nft.DELIM_NEWLINE) )
    fp.write("Data:" + nft.DELIM_NEWLINE)
    fp.write(" Ref: %s" % (fname_ref + nft.DELIM_NEWLINE))
    fp.write(" Hyp: %s" % (fname_hyp + nft.DELIM_NEWLINE + nft.DELIM_NEWLINE))

    # execute dp alignment scoring
    #
    print(" ... executing NEDC DP Alignment scoring ...")
    fp.write("%s\n%s (%s):\n\n" % 
             (NEDC_EVAL_SEP,
              ("NEDC DP Alignment Scoring Summary").upper(),
              NEDC_VERSION))
    fname = nft.concat_names(odir, NEDC_DPALIGN_FILE)
    status = ndpalign.run(ref_anns, hyp_anns, scmap, nedc_dpalign,
                          odir, fname, fp)
    if status == False:
        print("Error: %s (line: %s) %s: error in DPALIGN scoring" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)
    
    # execute NEDC epoch-based scoring
    #
    print(" ... executing NEDC Epoch scoring ...")
    fp.write("%s\n%s (%s):\n\n" % 
             (NEDC_EVAL_SEP,
              ("NEDC Epoch Scoring Summary").upper(),
              NEDC_VERSION))
    fname = nft.concat_names(odir, NEDC_EPOCH_FILE)
    status = nepoch.run(ref_anns, hyp_anns, scmap, nedc_epoch,
                        odir, fname, fp)
    if status == False:
        print("Error: %s (line: %s) %s: error in EPOCH scoring" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)

    # execute overlap scoring
    #
    print(" ... executing NEDC Overlap scoring ...")
    fp.write("%s\n%s (%s):\n\n" % 
             (NEDC_EVAL_SEP,
              ("NEDC Overlap Scoring Summary").upper(),
              NEDC_VERSION))
    fname = nft.concat_names(odir, NEDC_OVLP_FILE)
    status = novlp.run(ref_anns, hyp_anns, scmap, nedc_ovlp,
                       odir, fname, fp)
    if status == False:
        print("Error: %s (line: %s) %s: error in OVLP scoring" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)
        
    # execute time-aligned event scoring
    #
    print(" ... executing NEDC Time-Aligned Event scoring ...")
    fp.write("%s\n%s (%s):\n\n" % 
             (NEDC_EVAL_SEP,
              ("NEDC TAES Scoring Summary").upper(),
              NEDC_VERSION))
    fname = nft.concat_names(odir, NEDC_TAES_FILE)
    status = ntaes.run(ref_anns, hyp_anns, scmap, nedc_taes,
                       odir, fname, fp)
    if status == False:
        print("Error: %s (line: %s) %s: error in TAES scoring" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)

    # execute ira scoring                  
    #                                                                       
    print(" ... executing NEDC IRA scoring ...")
    fp.write("%s\n%s (%s):\n\n" % 
             (NEDC_EVAL_SEP,
              ("NEDC Inter-Rater Agreement Summary").upper(),
              NEDC_VERSION))
    fname = nft.concat_names(odir, NEDC_IRA_FILE)
    status = nira.run(ref_anns, hyp_anns, scmap, nedc_ira, odir, fp)
    if status == False:
        print("Error: %s (line: %s) %s: error in IRA scoring" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)

    # print the final message to the summary file, close it and exit
    #
    print(" ... done ...")
    fp.write("%s\nNEDC EEG Eval Successfully Completed on %s\n%s\n" \
             % (NEDC_EVAL_SEP, time.strftime("%c"), NEDC_EVAL_SEP))
    
    # close the output file
    #
    fp.close()

    # end of main
    #
    return True
    
#
# end of main

# begin gracefully
#
if __name__ == "__main__":
    main(sys.argv[0:])

#                                                                              
# end of file
@


1.22
log
@change the path of the help files.
@
text
@d58 1
a58 1
USAGE_FILE = "$NEDC_NFC/doc/usage/nedc_eeg_eval.usage"
d189 16
d225 14
@


1.21
log
@changed the location of the parameter file.
@
text
@d57 2
a58 2
HELP_FILE = "$NEDC_NFC/util/python/nedc_eeg_eval/nedc_eeg_eval.help"
USAGE_FILE = "$NEDC_NFC/util/python/nedc_eeg_eval/nedc_eeg_eval.usage"
@


1.20
log
@updated.
@
text
@d74 1
a74 1
DEF_PFILE = "$NEDC_NFC/util/python/nedc_eeg_eval/params_v00.toml"
@


1.19
log
@updated the default parameter path.
@
text
@d194 7
@


1.18
log
@updated to work with new parameter reading method
@
text
@d74 1
a74 1
DEF_PFILE = "$NEDC_NFC/util/python/nedc_eeg_eval/nedc_eeg_eval_params_v00.toml"
@


1.17
log
@fixed error related to not expanding file path variables
@
text
@d74 1
a74 1
DEF_PFILE = "$NEDC_NFC/util/python/nedc_eeg_eval/nedc_eeg_eval_params_v00.txt"
d157 1
a157 1
        
d202 1
a202 1

a266 1
    status = True
d326 1
a326 1
    nedc_ira = nft.load_parameters(pfile, nira.NEDC_IRA)
@


1.16
log
@updated the scoring output and added a log timestamp.
@
text
@d189 5
@


1.15
log
@updated.
@
text
@d93 1
a93 1
NEDC_VERSION = "NEDC EEG Eval (v6.0.0)"
d257 1
a257 1
    fp.write("%s\n%s\n\n" % 
d259 2
a260 1
              ("NEDC DP Alignment Scoring Summary (v4.0.0):").upper()))
d273 1
a273 1
    fp.write("%s\n%s\n\n" %
d275 2
a276 1
              ("NEDC Epoch Scoring Summary (v4.0.0):").upper()))
d288 1
a288 1
    fp.write("%s\n%s\n\n" %
d290 2
a291 1
              ("NEDC Overlap Scoring Summary (v4.0.0):").upper()))
d303 1
a303 1
    fp.write("%s\n%s\n\n" %
d305 2
a306 1
              ("NEDC TAES Scoring Summary (v4.0.0):").upper()))
d318 1
a318 1
    fp.write("%s\n%s\n\n" %
d320 2
a321 1
              ("NEDC Inter-Rater Agreement Summary (v4.0.0):").upper()))
@


1.14
log
@cosmetic.
@
text
@d7 1
d242 4
d248 5
a252 8
    fp.write("%s%s%s" % (NEDC_EVAL_SEP, nft.DELIM_NEWLINE, NEDC_VERSION) + \
             nft.DELIM_NEWLINE + nft.DELIM_NEWLINE)
    fp.write(" File: %s" % fname + nft.DELIM_NEWLINE) 
    fp.write(" Date: %s" % time.strftime("%c") + nft.DELIM_NEWLINE + \
             nft.DELIM_NEWLINE)
    fp.write(" Data:" + nft.DELIM_NEWLINE)
    fp.write("  Ref: %s" % fname_ref + nft.DELIM_NEWLINE)
    fp.write("  Hyp: %s" % fname_hyp + nft.DELIM_NEWLINE + nft.DELIM_NEWLINE)
@


1.13
log
@changed print_usage.
@
text
@d166 1
a166 1
    # convert the map:
@


1.12
log
@updated for the new environment.
@
text
@d134 1
a134 1
        cmdl.print_usage('stdout')
@


1.11
log
@*** empty log message ***
@
text
@d7 1
a7 1
# 20240515 (BRL): refactored code to match new naming, removed comp version
a29 2
import nedc_eeg_comp_tools as nct
import nedc_eeg_eval_common as nec
d36 6
a41 5
import nedc_eval_dpalign as ndpalign
import nedc_eval_epoch as nepoch
import nedc_eval_ovlp as novlp
import nedc_eval_taes as ntaes
import nedc_eval_ira as nira
d56 2
a57 2
HELP_FILE = "$NEDC_NFC/src/nedc_eeg_eval.help"
USAGE_FILE = "$NEDC_NFC/src/nedc_eeg_eval.usage"
d73 1
a73 1
DEF_PFILE = "$NEDC_NFC/src/nedc_eeg_eval_params_v00.txt"
a88 1

d92 1
a92 1
NEDC_VERSION = "NEDC EEG Eval (v5.0.0)"
a135 1

a147 1
        
a155 1
        
@


1.10
log
@updated.
@
text
@d30 2
a31 2
import nedc_comp_tools as nct
import nedc_eval_common as nec
@


1.9
log
@updated
@
text
@d3 1
a3 1
# file: $(NEDC_NFC)/util/python/nedc_eval_eeg/nedc_eval_eeg.py
d7 1
d57 2
a58 2
HELP_FILE = "$NEDC_NFC/src/nedc_eval_eeg.help"
USAGE_FILE = "$NEDC_NFC/src/nedc_eval_eeg.usage"
a68 2
ARG_COMP = "--competition"
ARG_ABRV_COMP = "-c"
d74 1
a74 1
DEF_PFILE = "$NEDC_NFC/src/nedc_eval_eeg_params_v00.txt"
a89 8
# define parameters for competition version:
#  the competition version does not use parameter files by default
#
DEF_COMP_DPALIGN = {'penalty_del': '1.0', 'penalty_ins': '1.0',
                    'penalty_sub': '1.0'}
DEF_COMP_EPOCH = {'epoch_duration': '0.25', 'null_class': 'BCKG'}
DEF_COMP_OVLP = {'guard_width': '0.001', 'ndigits_round': '3'}
DEF_COMP_TAES = {}
d94 1
a94 1
NEDC_VERSION = "NEDC Eval EEG (v5.0.0)"
a127 1
    cmdl.add_argument(ARG_ABRV_COMP, ARG_COMP, action = "store_true")
d139 1
a139 9
    # check if there are contradictions in the arguments provided
    #
    if (args.competition is not False) and (args.parameters is not None):
        print("Error: %s (line: %s) %s: %s" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               "parameters should not be specified for competition version"))
        cmdl.print_usage('stdout')
        sys.exit(os.EX_SOFTWARE)
        
d149 1
a149 1
    if (args.parameters is None) and (args.competition is False):
d152 2
a153 1
    # if using competition version, define parameters
d155 6
a160 14
    if args.competition is not False:
        nedc_dpalign = DEF_COMP_DPALIGN
        nedc_epoch = DEF_COMP_EPOCH
        nedc_ovlp = DEF_COMP_OVLP
        nedc_taes = DEF_COMP_TAES

    # if using research version, load parameters
    #
    else:
        nedc_dpalign = nft.load_parameters(pfile, ndpalign.NEDC_DPALIGN)
        nedc_epoch = nft.load_parameters(pfile, nepoch.NEDC_EPOCH)
        nedc_ovlp = nft.load_parameters(pfile, novlp.NEDC_OVLP)
        nedc_taes = nft.load_parameters(pfile, ntaes.NEDC_TAES)
        nedc_ira = nft.load_parameters(pfile, nira.NEDC_IRA)
d162 1
a162 1
    # load the scoring map for competition version 
d164 6
a169 14
    if args.competition is not False:
        tmpmap = {}
        for label in CLASSES:
            tmpmap[label] = label

    # load the scoring map for research version
    #
    else:
        tmpmap = nft.load_parameters(pfile, nec.PARAM_MAP)
        if (tmpmap == None):
            print("Error: %s (line: %s) %s: %s (%s)" %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__,
                   "error loading the scoring map",  pfile))
            sys.exit(os.EX_SOFTWARE)
a171 1
    #  note that both versions use the map
d188 1
a188 1
    # if using research version, parse the ref and hyp file lists 
d190 11
a200 27
    if args.competition is False:
        reflist = nft.get_flist(fname_ref)
        hyplist = nft.get_flist(fname_hyp)

        if dbgl > ndt.NONE:
            print("%s (line: %s) %s: ref list = " %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__), reflist)
            print("%s (line: %s) %s: hyp list = " %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__), hyplist)

        ref_anns = nec.parse_files(reflist, scmap)
        hyp_anns = nec.parse_files(hyplist, scmap)

        if dbgl > ndt.NONE:
            print("%s (line: %s) %s: ref_anns = " %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__), ref_anns)
            print("%s (line: %s) %s: hyp_anns = " %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__), hyp_anns)
            
    # if using competition version, parse the ref and hyp files:
    #  dur_dict is a dictionary that maps durations to file names and
    #  is created from the reference files to fill gaps in hypothesis
    #  files
    #
    else:
        ref_anns, dur_dict = nct.parse_file(fname_ref)
        hyp_anns = nct.parse_file(fname_hyp, dur_dict)
d202 6
d314 1
a314 1
    # execute ira scoring if using research version                  
d316 10
a325 11
    if args.competition is False:
        print(" ... executing NEDC IRA scoring ...")
        fp.write("%s\n%s\n\n" %
                 (NEDC_EVAL_SEP,
                  ("NEDC Inter-Rater Agreement Summary (v4.0.0):").upper()))
        nedc_ira = nft.load_parameters(pfile, nira.NEDC_IRA)
        status = nira.run(ref_anns, hyp_anns, scmap, nedc_ira, odir, fp)
        if status == False:
            print("Error: %s (line: %s) %s: error in IRA scoring" %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__))
            sys.exit(os.EX_SOFTWARE)
@


1.8
log
@fixed a bug - v4 => v5.
@
text
@d306 1
a306 1
              ("NEDC DP Alignment Scoring Summary (v5.0.0):").upper()))
d321 1
a321 1
              ("NEDC Epoch Scoring Summary (v5.0.0):").upper()))
d335 1
a335 1
              ("NEDC Overlap Scoring Summary (v5.0.0):").upper()))
d349 1
a349 1
              ("NEDC TAES Scoring Summary (v5.0.0):").upper()))
d364 1
a364 1
                  ("NEDC Inter-Rater Agreement Summary (v5.0.0):").upper()))
@


1.7
log
@completed refactoring the code.
@
text
@d306 1
a306 1
              ("NEDC DP Alignment Scoring Summary (v4.0.0):").upper()))
d321 1
a321 1
              ("NEDC Epoch Scoring Summary (v4.0.0):").upper()))
d335 1
a335 1
              ("NEDC Overlap Scoring Summary (v4.0.0):").upper()))
d349 1
a349 1
              ("NEDC TAES Scoring Summary (v4.0.0):").upper()))
d364 1
a364 1
                  ("NEDC Inter-Rater Agreement Summary (v4.0.0):").upper()))
@


1.6
log
@updated to make it relocatable.
@
text
@d7 1
a52 4
# define script location
#
SCRIPT_LOC = os.path.dirname(os.path.realpath(__file__))
 
d75 1
a75 2
DEF_PFILE = \
    "$NEDC_NFC/src/nedc_eval_eeg_params_v00.txt"
d105 4
a108 1
# define class definitions
d305 1
a305 1
             (NEDC_EVAL_SEP, \
d319 3
a321 2
    fp.write("%s\n%s\n\n" % (NEDC_EVAL_SEP, \
                             "NEDC Epoch Scoring Summary (v4.0.0):"))
d333 3
a335 2
    fp.write("%s\n%s\n\n" % (NEDC_EVAL_SEP, \
                             "NEDC Overlap Scoring Summary (v4.0.0):"))
d347 3
a349 2
    fp.write("%s\n%s\n\n" % (NEDC_EVAL_SEP, \
                             "NEDC TAES Scoring Summary (v4.0.0):"))
d362 3
a364 2
        fp.write("%s\n%s\n\n" % (NEDC_EVAL_SEP,
                            "NEDC Inter-Rater Agreement Summary (v4.0.0):"))
@


1.5
log
@added a comment.
@
text
@d56 2
a57 1
# define the help file and usage message
d59 2
a60 2
HELP_FILE = "$NEDC_NFC/util/python/nedc_eval_eeg/nedc_eval_eeg.help"
USAGE_FILE = "$NEDC_NFC/util/python/nedc_eval_eeg/nedc_eval_eeg.usage"
d79 1
a79 1
    "$NEDC_NFC/util/python/nedc_eval_eeg/nedc_eval_eeg_params_v00.txt"
@


1.4
log
@updated to use the new ann tools.
@
text
@d7 1
a7 1
# 20220427 (JP): updated I/O to suppoer csv and xml
@


1.3
log
@*** empty log message ***
@
text
@d7 1
a102 1

d106 1
a106 1
NEDC_VERSION = "NEDC Eval EEG (v4.0.0)"
d116 1
a116 1
# the main program starts here
d120 1
a120 1
# method: main
d122 3
a124 5
# arguments: none
#
# return: none
#
# This function is the main program.
a127 9
    # declare local variables
    #
    status = True
    dbgl = ndt.Dbgl()
    
    # declare default values for command line arguments
    #
    odir = nft.get_fullpath(DEF_ODIR)

a142 8
    if dbgl > ndt.NONE:
        print("command line arguments:")
        print(" output directory = %s" % (args.odir))
        print(" competition = %d" % (bool(args.competition)))
        print(" ref file  = %s" % (args.files[0]))
        print(" hyp file = %s" % (args.files[1]))
        print("")
        
d160 1
d187 30
a226 2
        ref_anns = nec.parse_files(reflist)
        hyp_anns = nec.parse_files(hyplist)
d228 15
d252 12
a278 26
    # load the scoring map for competition version 
    #
    if args.competition is not False:
        tmpmap = {}
        for label in CLASSES:
            tmpmap[label] = label

    # load the scoring map for research version
    #
    else:
        tmpmap = nft.load_parameters(pfile, nec.PARAM_MAP)
        if (tmpmap == None):
            print("Error: %s (line: %s) %s: %s (%s)" %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__,
                   "error loading the scoring map",  pfile))
            sys.exit(os.EX_SOFTWARE)

    # convert the map:
    #  note that both versions use the map
    #
    scmap = nft.generate_map(tmpmap)
    if (scmap == None):
        print("Error: %s (line: %s) %s: error converting the map" % 
              (__FILE__, ndt.__LINE__, ndt.__NAME__))
        sys.exit(os.EX_SOFTWARE)

d308 1
d380 1
a380 1
    sys.exit(os.EX_OK)
@


1.2
log
@deprecated the NIST software.
@
text
@a265 1
        print(tmpmap)
@


1.1
log
@Initial revision
@
text
@d7 1
a34 1
import nedc_eval_nist as nnist
a68 3
ARG_NIST = "--nist"
ARG_ABRV_NIST = "-n"

a87 1
NEDC_NIST_FILE = "summary_nist.txt"
a148 1
    cmdl.add_argument(ARG_ABRV_NIST, ARG_NIST, action = "store_true")
a156 1
        print(" nist = %s" % (bool(args.nist)))
a169 7
    if (args.competition is not False) and (args.nist is not False):
        print("Error: %s (line: %s) %s: %s" %
              (__FILE__, ndt.__LINE__, ndt.__NAME__,
               "competiton and NIST args cannot be specified together"))
        cmdl.print_usage('stdout')
        sys.exit(os.EX_SOFTWARE)

a203 5

    # if using NIST scoring algorithm, load NIST parameters
    #
    if args.nist is not False:
        nist_f4de = nft.load_parameters(pfile, nnist.NIST_F4DE)
a290 17
    # execute NIST scoring if NIST option used
    #
    if args.nist is not False:
        print(" ... executing NIST ATWV scoring ...")
        fp.write("%s\n%s\n\n" %
                 (NEDC_EVAL_SEP,
                  ("NIST ATWV Scoring Summary (f4de_3.3.1):").upper()))

        # pass the original file list to the NIST software
        #
        status = nnist.run(reflist, hyplist, scmap, nist_f4de,
                       odir, NEDC_NIST_FILE, fp)
        if status == False:
            print("Error: %s (line: %s) %s: error in NIST scoring" %
                  (__FILE__, ndt.__LINE__, ndt.__NAME__))
            sys.exit(os.EX_SOFTWARE)
            
@
